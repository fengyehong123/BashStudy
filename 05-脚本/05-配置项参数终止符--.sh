#!/usr/bin/env bash

# ---------------------------------------------------------------------------------------------------
# ⏹遇到的问题
# -和--开头的参数，会被 Bash 当作配置项解释。
# 但是，有时它们不是配置项，而是实体参数的一部分，比如文件名叫做-f或--file。
#
# cat -f
# cat --file
# 
# 😵上面命令的原意是输出文件-f和--file的内容，但是会被 Bash 当作配置项解释。😵
# ---------------------------------------------------------------------------------------------------

# 下面这两种写法都可以确保，当路径不存在的时候，退出脚本的执行
cd 05-脚本 || exit
# cd 05-脚本 || return


# ---------------------------------------------------------------------------------------------------
# ⏹可以使用配置项参数终止符 --
# 它的作用是告诉 Bash，在它后面的参数开头的-和--不是配置项，只能当作实体参数解释。
# 有两个文件
#   -f 和 --file
# ---------------------------------------------------------------------------------------------------
cat -- -f
cat -- --file
echo -e "\e[1;31m/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_分割线_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_\e[0m"

my_path='-l'

# 如果没有 -- ，那么 ls 会将 $my_path 当做配置项来看待，所以会列出当前目录下的所有文件
ls $my_path

# 使用 -- 来将 $my_path 当做实体参数(路径名)来解释，如果 $my_path 所对应的值不是路径的话，就会报错
ls -- $my_path

echo -e "\e[1;31m/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_分割线_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_\e[0m"

# ---------------------------------------------------------------------------------------------------
# ⏹如果想要在文件中搜索 --hello 的话，也需要加上 -- 
# 否则会将 --hello 或 -hello 当做配置项来看待
# ---------------------------------------------------------------------------------------------------
grep -- "--hello" 00-example.txt
grep -- "-hello" 00-example.txt