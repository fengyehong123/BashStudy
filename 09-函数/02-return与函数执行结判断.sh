#!/usr/bin/env bash

# ---------------------------------------------------------------------------------------------------
# ⏹return 命令
# 1. return命令用于从函数返回一个值。
#    函数执行到这条命令，就不再往下执行了，直接返回了。
#    bash函数的返回值只能是整数(通常用作退出状态)
# 2. 通过 $? 可以获取到函数的返回值
# ---------------------------------------------------------------------------------------------------

function get_user_info() {

    echo 'Hello World!'
    # 💥只能返回0到255的数字
    return 10
}

# 调用函数并且获取其返回值
get_user_info
echo "函数的返回值为: $?"  # 函数的返回值为: 10

# ---------------------------------------------------------------------------------------------------
# ⏹Bash只能返回整数(0到255)
# 但是可以通过其他方式让函数变通的返回其他值(例如数组)
# 1. 使用全局变量
# 2. 通过命令替换(💥Bash4及以上可用💥) 😓不推荐使用😓
# 3. 通过引用传递(💥Bash4及以上可用💥)
# ---------------------------------------------------------------------------------------------------

# 1. 使用全局变量获取返回值
function func1() {

    # 通过local初始化一个局部变量的数组
    local arr=('香蕉1' '苹果1' '橘子1')
    # 向数组内添加一个元素
    arr+=('西瓜1 哈哈')

    # 将结果赋值给全局变量
    result1=("${arr[@]}")

    # 明确的返回0，表示函数执行成功
    # 返回0之外的其他数字，在语义上表示函数执行失败
    return 0
}

# 调用函数
func1
# 🐳获取func1的返回值
for ele in "${result1[@]}"; do
    echo "$ele"
done
# 香蕉1
# 苹果1
# 橘子1
# 西瓜1 哈哈

# -----------------------------------------------
# shellcheck disable=SC2181
# shellcheck disable=SC2319
# -----------------------------------------------
# $? -ne 0 判断函数失败，可以通过 ! func1 来代替
# $? -eq 0 判断函数成功，可以通过 func1 来代替
# -----------------------------------------------
# 😵😵😵不推荐下面这种写法😵😵😵
if [[ $? -ne 0 ]]; then
    echo "。。。。func1函数执行失败。。。。"
elif [[ $? -eq 0 ]]; then
    echo "func1函数执行成功!"
fi

# 🔴更加推荐的判断函数是否执行成功的方式🔴
if ! func1; then
    echo "....函数执行失败...."
elif func1; then
    echo "函数执行成功!"
fi

echo -e "\e[1;31m/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_分割线_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_\e[0m"

# 2. 通过命令替换获取函数的返回值
# 😓😓😓不推荐使用😓😓😓
function func2() {

    local arr=('香蕉2' '苹果2' '橘子2')
    # 💥注意，该元素中间有空格💥
    arr+=('西瓜2 哈哈')

    # 打印需要返回的值
    echo "${arr[@]}"

    # 没有明确的返回0之外的数字的话，默认返回0，表示函数执行成功
    # return 0
}

# shellcheck disable=SC2207
# ❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌
# ❌'西瓜2 哈哈' 中间有一个空格,这种写法会将 '西瓜2 哈哈' 这个元素错误的切分为 【西瓜2】 和 【哈哈】 这两个元素                     ❌      
# ❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌❌
result2=( $(func2) )
# 🐳获取func2的返回值
for ele in "${result2[@]}"; do
    echo "$ele"
done
# 香蕉2
# 苹果2
# 橘子2
# 西瓜2
# 哈哈

echo -e "\e[1;31m/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_分割线_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_\e[0m"

# 3. 通过引用传递（传递数组变量）
# Bash4及以上可用
function func3() {

    # ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
    # ⭐使用 -n 来创建一个变量引用    ⭐
    # ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
    local -n arr_ref=$1

    arr_ref=('香蕉3' '苹果3' '橘子3')
    # 💥注意，该元素中间有空格💥
    arr_ref+=('西瓜3 哈哈')

    # 没有明确的返回0之外的数字的话，默认返回0，表示函数执行成功
    # return 0
}

# 定义一个空数组
result3=()
# 在调用函数时，将空数组当做参数引用传递
func3 result3
# 🐳获取func3的返回值
for ele in "${result3[@]}"; do
    echo "$ele"
done
# 香蕉3
# 苹果3
# 橘子3
# 西瓜3 哈哈