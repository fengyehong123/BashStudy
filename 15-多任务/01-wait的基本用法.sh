#!/usr/bin/env bash

# _____________________________________________________________________
#   $! → 保存最近一个后台进程的 PID，常配合 wait 使用。
#   $$ → 获取当前脚本的 PID
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
echo "脚本 PID: $$"
echo "脚本开始: $(date +%T)"
echo -e "\e[1;31m------------脚本开始: $(date +%T)------------\e[0m"
# ______________________________________
# 脚本中的耗时任务添加了 & ，因此会并行执行
#   ⏹执行过程
#     sleep 3 & 启动一个后台进程，马上继续执行下一行。
#     sleep 5 & 启动第二个后台进程，马上继续执行下一行。
#     wait 会等待 所有后台进程都结束。
#   ⏹总耗时
#     两个 sleep 是并行的。
#     所以总耗时 = max(3, 5) = 5 秒。
# ___________ 启动两个后台任务 ___________ 
(sleep 3; echo '【sleep 3】的任务结束') &
pid1=$!
echo "启动任务1 (sleep 3), 子进程 PID=$pid1"

(sleep 5; echo '【sleep 5】的任务结束') &
pid2=$!
echo "启动任务2 (sleep 5), 子进程 PID=$pid2"
# ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾

# 🔴通过 wait 来等待所有子进程完成🔴
wait
echo -e "\e[1;31m------------脚本终了: $(date +%T)------------\e[0m"
# __________________________________________________________________________________________________________

echo -e "\e[1;32m------------顺序执行开始: $(date +%T)------------\e[0m"

# 给耗时任务去掉 & 之后，任务就会顺次执行了，必须等到前一个耗时任务完全结束才能开启下一个任务
# 因此总耗时为 8秒
sleep 3; echo '【sleep 3】的任务结束'
sleep 5; echo '【sleep 5】的任务结束'

echo -e "\e[1;32m------------顺序执行结束: $(date +%T)------------\e[0m"

