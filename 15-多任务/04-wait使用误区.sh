#!/usr/bin/env bash

echo -e "\e[1;31m------------脚本开始: $(date +%T)------------\e[0m"
# 😒做法：
#   sleep 3 & → 把 sleep 放到 后台。
#   wait $! → 等待刚才的后台任务完成。
# ⚡ 实际效果：
#   虽然你用了 & 把 sleep 放后台，但紧接着 wait $! 等待它结束。
#   所以每次循环还是要 等 3 秒，循环 3 次 → 总耗时 ≈ 9 秒。
for i in {1..3}; do
    echo "开始任务 $i"
    sleep 3 &
    wait $!   
    echo "任务 $i 完成"
done
echo -e "\e[1;31m------------脚本结束: $(date +%T)------------\e[0m"

echo -e "\e[1;32m------------脚本开始: $(date +%T)------------\e[0m"
# sleep 3 → 前台执行，直接阻塞 3 秒。
# 循环 3 次 → 总耗时 ≈ 9 秒。
# ✅ 总结
#   两种写法 耗时完全一样，因为第一种虽然用了后台执行，但马上又用 wait $! 阻塞等待，效果相当于顺序执行。
for i in {1..3}; do
    echo "开始任务 $i"
    sleep 3
    echo "任务 $i 完成"
done
echo -e "\e[1;32m------------脚本结束: $(date +%T)------------\e[0m"

echo -e "\e[1;31m------------脚本开始: $(date +%T)------------\e[0m"
# 💡 提示：
#   只有 不立即 wait 才能真正实现并行任务，或者一次性把多个后台任务都启动完，再统一 wait。
for i in {1..3}; do
    sleep 3 &
done
wait
echo "所有的任务都完成了"
echo -e "\e[1;31m------------脚本结束: $(date +%T)------------\e[0m"

